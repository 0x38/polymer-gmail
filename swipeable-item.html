<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="bower_components/core-style/core-style.html">

<core-style id="swipeable">
  .snapback {
    transition: all 300ms ease-in-out;
    transform: none !important;
    opacity: 1 !important;
  }
  .offscreen {
    transition: all 300ms linear;
    opacity: 0 !important;
  }
</core-style>

<!--
Adds swiping functionality to an element.

##### Example

    <mail-thread></mail-thread>

@element mail-thread
@extends swipeable-item
-->
<polymer-element name="swipeable-item" attributes="swipeTarget" touch-action="pan-y">
  <script>
    Polymer({
      SWIPE_THREASHOLD: 10,

      /**
       * The last swiping direction. -1: sliding left, 1: sliding right
       *
       * @property lastDirection
       * @type number
       * @default null
       */
      lastDirection: null,

      /**
       * The target node for track events. If none is provided, the parentElement
       * of this element is used as the target.
       *
       * @attribute swipeTarget
       * @type DOMElement
       * @default null
       */
      swipeTarget: null,

      /**
       * True if the element being swiped should proceed offscreen.
       *
       * @property swipeOff
       * @type bool
       * @default false
       */
      swipeOff: false,

      eventDelegates: {
        track: 'onTrack',
        trackend: 'onTrackEnd',
        transitionend: 'onSnapedBack'
      },

      domReady: function() {
        this.width = this.swipeTarget.clientWidth; // cache it.
      },

      swipeTargetChanged: function() {
        this.swipeTarget = this.swipeTarget || this.parentElement;
      },

      onTrack: function(e, detail, sender) {
        this.lastDirection = e.xDirection;
        this.last_ddx_ = e.ddx;

        var style = this.swipeTarget.style;
        style.transform = 'translateX(' + e.dx + 'px)';
        style.opacity = 1 - (Math.abs(e.dx) / this.width);
      },

      onTrackEnd: function(e, detail, sender) {
        // Swipe the time offscreen if it was fast.
        if (Math.abs(this.last_ddx_) > this.SWIPE_THREASHOLD) {
          this.swipeOff = true;
          this.swipeTarget.style.transition = 'all 100ms linear';
          return;
        }

        // Slide all the way off (left/right) if we're 50% slide.
        if (Math.abs(e.dx) >= this.width / 2) {
          this.swipeOff = true;
        } else {
          this.swipeTarget.classList.add('snapback');
        }
      },

      onSnapedBack: function(e, detail, sender) {
        // If item is already swiped offscreen, don't snap it back.
        if (this.swipeTarget.classList.contains('offscreen')) {
          return;
        }

        if (e.propertyName == 'transform') {
          var style = this.swipeTarget.style;
          style.transform = '';
          style.opacity = '';
          this.swipeTarget.classList.remove('snapback');
        }
      },

      swipeOffChanged: function() {
        if (this.swipeOff) {
          this.swipeTarget.classList.add('offscreen');
          this.swipeTarget.style.transform =
              'translateX(' + (this.lastDirection * this.width) + 'px)';
        } else {
          this.swipeTarget.style.transition = '';
          this.swipeTarget.style.transform = 'translateX(' + this.width + 'px)';
          this.swipeTarget.classList.remove('offscreen');
          
          // Native app always comes back from right. Need to wait one rAF for
          // .offscreen to have been applied.
          this.async(function() {
            this.swipeTarget.classList.add('snapback');
          });
        }
      }

    });
  </script>
</polymer-element>